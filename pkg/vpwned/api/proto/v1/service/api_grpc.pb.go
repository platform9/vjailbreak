// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v6.32.0
// source: sdk/proto/v1/api.proto

// editor setting.
// Tab size=4; Tabs as spaces; Clean up trailing whitespaces.

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Version_Version_FullMethodName            = "/api.Version/Version"
	Version_InitiateUpgrade_FullMethodName    = "/api.Version/InitiateUpgrade"
	Version_GetUpgradeProgress_FullMethodName = "/api.Version/GetUpgradeProgress"
	Version_GetAvailableTags_FullMethodName   = "/api.Version/GetAvailableTags"
	Version_Cleanup_FullMethodName            = "/api.Version/Cleanup"
)

// VersionClient is the client API for Version service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionClient interface {
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	InitiateUpgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
	GetUpgradeProgress(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*UpgradeProgressResponse, error)
	GetAvailableTags(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*AvailableUpdatesResponse, error)
	Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error)
}

type versionClient struct {
	cc grpc.ClientConnInterface
}

func NewVersionClient(cc grpc.ClientConnInterface) VersionClient {
	return &versionClient{cc}
}

func (c *versionClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, Version_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) InitiateUpgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, Version_InitiateUpgrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) GetUpgradeProgress(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*UpgradeProgressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpgradeProgressResponse)
	err := c.cc.Invoke(ctx, Version_GetUpgradeProgress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) GetAvailableTags(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*AvailableUpdatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AvailableUpdatesResponse)
	err := c.cc.Invoke(ctx, Version_GetAvailableTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) Cleanup(ctx context.Context, in *CleanupRequest, opts ...grpc.CallOption) (*CleanupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CleanupResponse)
	err := c.cc.Invoke(ctx, Version_Cleanup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VersionServer is the server API for Version service.
// All implementations must embed UnimplementedVersionServer
// for forward compatibility.
type VersionServer interface {
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
	InitiateUpgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error)
	GetUpgradeProgress(context.Context, *VersionRequest) (*UpgradeProgressResponse, error)
	GetAvailableTags(context.Context, *VersionRequest) (*AvailableUpdatesResponse, error)
	Cleanup(context.Context, *CleanupRequest) (*CleanupResponse, error)
	mustEmbedUnimplementedVersionServer()
}

// UnimplementedVersionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVersionServer struct{}

func (UnimplementedVersionServer) Version(context.Context, *VersionRequest) (*VersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedVersionServer) InitiateUpgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InitiateUpgrade not implemented")
}
func (UnimplementedVersionServer) GetUpgradeProgress(context.Context, *VersionRequest) (*UpgradeProgressResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUpgradeProgress not implemented")
}
func (UnimplementedVersionServer) GetAvailableTags(context.Context, *VersionRequest) (*AvailableUpdatesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAvailableTags not implemented")
}
func (UnimplementedVersionServer) Cleanup(context.Context, *CleanupRequest) (*CleanupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedVersionServer) mustEmbedUnimplementedVersionServer() {}
func (UnimplementedVersionServer) testEmbeddedByValue()                 {}

// UnsafeVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServer will
// result in compilation errors.
type UnsafeVersionServer interface {
	mustEmbedUnimplementedVersionServer()
}

func RegisterVersionServer(s grpc.ServiceRegistrar, srv VersionServer) {
	// If the following call panics, it indicates UnimplementedVersionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Version_ServiceDesc, srv)
}

func _Version_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Version_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_InitiateUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).InitiateUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Version_InitiateUpgrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).InitiateUpgrade(ctx, req.(*UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_GetUpgradeProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).GetUpgradeProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Version_GetUpgradeProgress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).GetUpgradeProgress(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_GetAvailableTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).GetAvailableTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Version_GetAvailableTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).GetAvailableTags(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Version_Cleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).Cleanup(ctx, req.(*CleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Version_ServiceDesc is the grpc.ServiceDesc for Version service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Version_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Version",
	HandlerType: (*VersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Version_Version_Handler,
		},
		{
			MethodName: "InitiateUpgrade",
			Handler:    _Version_InitiateUpgrade_Handler,
		},
		{
			MethodName: "GetUpgradeProgress",
			Handler:    _Version_GetUpgradeProgress_Handler,
		},
		{
			MethodName: "GetAvailableTags",
			Handler:    _Version_GetAvailableTags_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _Version_Cleanup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	VCenter_ListVMs_FullMethodName      = "/api.VCenter/ListVMs"
	VCenter_GetVM_FullMethodName        = "/api.VCenter/GetVM"
	VCenter_ReclaimVM_FullMethodName    = "/api.VCenter/ReclaimVM"
	VCenter_CordonHost_FullMethodName   = "/api.VCenter/CordonHost"
	VCenter_UnCordonHost_FullMethodName = "/api.VCenter/UnCordonHost"
	VCenter_ListHosts_FullMethodName    = "/api.VCenter/ListHosts"
)

// VCenterClient is the client API for VCenter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VCenterClient interface {
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error)
	ReclaimVM(ctx context.Context, in *ReclaimVMRequest, opts ...grpc.CallOption) (*ReclaimVMResponse, error)
	CordonHost(ctx context.Context, in *CordonHostRequest, opts ...grpc.CallOption) (*CordonHostResponse, error)
	UnCordonHost(ctx context.Context, in *UnCordonHostRequest, opts ...grpc.CallOption) (*UnCordonHostResponse, error)
	ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error)
}

type vCenterClient struct {
	cc grpc.ClientConnInterface
}

func NewVCenterClient(cc grpc.ClientConnInterface) VCenterClient {
	return &vCenterClient{cc}
}

func (c *vCenterClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, VCenter_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVMResponse)
	err := c.cc.Invoke(ctx, VCenter_GetVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) ReclaimVM(ctx context.Context, in *ReclaimVMRequest, opts ...grpc.CallOption) (*ReclaimVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReclaimVMResponse)
	err := c.cc.Invoke(ctx, VCenter_ReclaimVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) CordonHost(ctx context.Context, in *CordonHostRequest, opts ...grpc.CallOption) (*CordonHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CordonHostResponse)
	err := c.cc.Invoke(ctx, VCenter_CordonHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) UnCordonHost(ctx context.Context, in *UnCordonHostRequest, opts ...grpc.CallOption) (*UnCordonHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnCordonHostResponse)
	err := c.cc.Invoke(ctx, VCenter_UnCordonHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHostsResponse)
	err := c.cc.Invoke(ctx, VCenter_ListHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VCenterServer is the server API for VCenter service.
// All implementations must embed UnimplementedVCenterServer
// for forward compatibility.
type VCenterServer interface {
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error)
	ReclaimVM(context.Context, *ReclaimVMRequest) (*ReclaimVMResponse, error)
	CordonHost(context.Context, *CordonHostRequest) (*CordonHostResponse, error)
	UnCordonHost(context.Context, *UnCordonHostRequest) (*UnCordonHostResponse, error)
	ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error)
	mustEmbedUnimplementedVCenterServer()
}

// UnimplementedVCenterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVCenterServer struct{}

func (UnimplementedVCenterServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedVCenterServer) GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVM not implemented")
}
func (UnimplementedVCenterServer) ReclaimVM(context.Context, *ReclaimVMRequest) (*ReclaimVMResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReclaimVM not implemented")
}
func (UnimplementedVCenterServer) CordonHost(context.Context, *CordonHostRequest) (*CordonHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CordonHost not implemented")
}
func (UnimplementedVCenterServer) UnCordonHost(context.Context, *UnCordonHostRequest) (*UnCordonHostResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnCordonHost not implemented")
}
func (UnimplementedVCenterServer) ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListHosts not implemented")
}
func (UnimplementedVCenterServer) mustEmbedUnimplementedVCenterServer() {}
func (UnimplementedVCenterServer) testEmbeddedByValue()                 {}

// UnsafeVCenterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VCenterServer will
// result in compilation errors.
type UnsafeVCenterServer interface {
	mustEmbedUnimplementedVCenterServer()
}

func RegisterVCenterServer(s grpc.ServiceRegistrar, srv VCenterServer) {
	// If the following call panics, it indicates UnimplementedVCenterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VCenter_ServiceDesc, srv)
}

func _VCenter_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).GetVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_GetVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).GetVM(ctx, req.(*GetVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_ReclaimVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReclaimVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ReclaimVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_ReclaimVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ReclaimVM(ctx, req.(*ReclaimVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_CordonHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CordonHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).CordonHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_CordonHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).CordonHost(ctx, req.(*CordonHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_UnCordonHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnCordonHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).UnCordonHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_UnCordonHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).UnCordonHost(ctx, req.(*UnCordonHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_ListHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ListHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_ListHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ListHosts(ctx, req.(*ListHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VCenter_ServiceDesc is the grpc.ServiceDesc for VCenter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VCenter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.VCenter",
	HandlerType: (*VCenterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListVMs",
			Handler:    _VCenter_ListVMs_Handler,
		},
		{
			MethodName: "GetVM",
			Handler:    _VCenter_GetVM_Handler,
		},
		{
			MethodName: "ReclaimVM",
			Handler:    _VCenter_ReclaimVM_Handler,
		},
		{
			MethodName: "CordonHost",
			Handler:    _VCenter_CordonHost_Handler,
		},
		{
			MethodName: "UnCordonHost",
			Handler:    _VCenter_UnCordonHost_Handler,
		},
		{
			MethodName: "ListHosts",
			Handler:    _VCenter_ListHosts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	BMProvider_ListMachines_FullMethodName          = "/api.BMProvider/ListMachines"
	BMProvider_GetResourceInfo_FullMethodName       = "/api.BMProvider/GetResourceInfo"
	BMProvider_SetResourcePower_FullMethodName      = "/api.BMProvider/SetResourcePower"
	BMProvider_SetResourceBM2PXEBoot_FullMethodName = "/api.BMProvider/SetResourceBM2PXEBoot"
	BMProvider_WhoAmI_FullMethodName                = "/api.BMProvider/WhoAmI"
	BMProvider_ListBootSource_FullMethodName        = "/api.BMProvider/ListBootSource"
	BMProvider_ReclaimBMHost_FullMethodName         = "/api.BMProvider/ReclaimBMHost"
	BMProvider_DeployMachine_FullMethodName         = "/api.BMProvider/DeployMachine"
)

// BMProviderClient is the client API for BMProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BMProviderClient interface {
	ListMachines(ctx context.Context, in *BMListMachinesRequest, opts ...grpc.CallOption) (*BMListMachinesResponse, error)
	GetResourceInfo(ctx context.Context, in *GetResourceInfoRequest, opts ...grpc.CallOption) (*GetResourceInfoResponse, error)
	SetResourcePower(ctx context.Context, in *SetResourcePowerRequest, opts ...grpc.CallOption) (*SetResourcePowerResponse, error)
	SetResourceBM2PXEBoot(ctx context.Context, in *SetResourceBM2PXEBootRequest, opts ...grpc.CallOption) (*SetResourceBM2PXEBootResponse, error)
	WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error)
	ListBootSource(ctx context.Context, in *ListBootSourceRequest, opts ...grpc.CallOption) (*ListBootSourceResponse, error)
	ReclaimBMHost(ctx context.Context, in *ReclaimBMRequest, opts ...grpc.CallOption) (*ReclaimBMResponse, error)
	DeployMachine(ctx context.Context, in *DeployMachineRequest, opts ...grpc.CallOption) (*DeployMachineResponse, error)
}

type bMProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewBMProviderClient(cc grpc.ClientConnInterface) BMProviderClient {
	return &bMProviderClient{cc}
}

func (c *bMProviderClient) ListMachines(ctx context.Context, in *BMListMachinesRequest, opts ...grpc.CallOption) (*BMListMachinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BMListMachinesResponse)
	err := c.cc.Invoke(ctx, BMProvider_ListMachines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) GetResourceInfo(ctx context.Context, in *GetResourceInfoRequest, opts ...grpc.CallOption) (*GetResourceInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResourceInfoResponse)
	err := c.cc.Invoke(ctx, BMProvider_GetResourceInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) SetResourcePower(ctx context.Context, in *SetResourcePowerRequest, opts ...grpc.CallOption) (*SetResourcePowerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResourcePowerResponse)
	err := c.cc.Invoke(ctx, BMProvider_SetResourcePower_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) SetResourceBM2PXEBoot(ctx context.Context, in *SetResourceBM2PXEBootRequest, opts ...grpc.CallOption) (*SetResourceBM2PXEBootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResourceBM2PXEBootResponse)
	err := c.cc.Invoke(ctx, BMProvider_SetResourceBM2PXEBoot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WhoAmIResponse)
	err := c.cc.Invoke(ctx, BMProvider_WhoAmI_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) ListBootSource(ctx context.Context, in *ListBootSourceRequest, opts ...grpc.CallOption) (*ListBootSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBootSourceResponse)
	err := c.cc.Invoke(ctx, BMProvider_ListBootSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) ReclaimBMHost(ctx context.Context, in *ReclaimBMRequest, opts ...grpc.CallOption) (*ReclaimBMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReclaimBMResponse)
	err := c.cc.Invoke(ctx, BMProvider_ReclaimBMHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) DeployMachine(ctx context.Context, in *DeployMachineRequest, opts ...grpc.CallOption) (*DeployMachineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeployMachineResponse)
	err := c.cc.Invoke(ctx, BMProvider_DeployMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BMProviderServer is the server API for BMProvider service.
// All implementations must embed UnimplementedBMProviderServer
// for forward compatibility.
type BMProviderServer interface {
	ListMachines(context.Context, *BMListMachinesRequest) (*BMListMachinesResponse, error)
	GetResourceInfo(context.Context, *GetResourceInfoRequest) (*GetResourceInfoResponse, error)
	SetResourcePower(context.Context, *SetResourcePowerRequest) (*SetResourcePowerResponse, error)
	SetResourceBM2PXEBoot(context.Context, *SetResourceBM2PXEBootRequest) (*SetResourceBM2PXEBootResponse, error)
	WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error)
	ListBootSource(context.Context, *ListBootSourceRequest) (*ListBootSourceResponse, error)
	ReclaimBMHost(context.Context, *ReclaimBMRequest) (*ReclaimBMResponse, error)
	DeployMachine(context.Context, *DeployMachineRequest) (*DeployMachineResponse, error)
	mustEmbedUnimplementedBMProviderServer()
}

// UnimplementedBMProviderServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBMProviderServer struct{}

func (UnimplementedBMProviderServer) ListMachines(context.Context, *BMListMachinesRequest) (*BMListMachinesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMachines not implemented")
}
func (UnimplementedBMProviderServer) GetResourceInfo(context.Context, *GetResourceInfoRequest) (*GetResourceInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetResourceInfo not implemented")
}
func (UnimplementedBMProviderServer) SetResourcePower(context.Context, *SetResourcePowerRequest) (*SetResourcePowerResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetResourcePower not implemented")
}
func (UnimplementedBMProviderServer) SetResourceBM2PXEBoot(context.Context, *SetResourceBM2PXEBootRequest) (*SetResourceBM2PXEBootResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetResourceBM2PXEBoot not implemented")
}
func (UnimplementedBMProviderServer) WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WhoAmI not implemented")
}
func (UnimplementedBMProviderServer) ListBootSource(context.Context, *ListBootSourceRequest) (*ListBootSourceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBootSource not implemented")
}
func (UnimplementedBMProviderServer) ReclaimBMHost(context.Context, *ReclaimBMRequest) (*ReclaimBMResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReclaimBMHost not implemented")
}
func (UnimplementedBMProviderServer) DeployMachine(context.Context, *DeployMachineRequest) (*DeployMachineResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeployMachine not implemented")
}
func (UnimplementedBMProviderServer) mustEmbedUnimplementedBMProviderServer() {}
func (UnimplementedBMProviderServer) testEmbeddedByValue()                    {}

// UnsafeBMProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BMProviderServer will
// result in compilation errors.
type UnsafeBMProviderServer interface {
	mustEmbedUnimplementedBMProviderServer()
}

func RegisterBMProviderServer(s grpc.ServiceRegistrar, srv BMProviderServer) {
	// If the following call panics, it indicates UnimplementedBMProviderServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BMProvider_ServiceDesc, srv)
}

func _BMProvider_ListMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BMListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ListMachines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_ListMachines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ListMachines(ctx, req.(*BMListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_GetResourceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).GetResourceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_GetResourceInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).GetResourceInfo(ctx, req.(*GetResourceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_SetResourcePower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourcePowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).SetResourcePower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_SetResourcePower_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).SetResourcePower(ctx, req.(*SetResourcePowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_SetResourceBM2PXEBoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourceBM2PXEBootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).SetResourceBM2PXEBoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_SetResourceBM2PXEBoot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).SetResourceBM2PXEBoot(ctx, req.(*SetResourceBM2PXEBootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_WhoAmI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhoAmIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).WhoAmI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_WhoAmI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).WhoAmI(ctx, req.(*WhoAmIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_ListBootSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBootSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ListBootSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_ListBootSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ListBootSource(ctx, req.(*ListBootSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_ReclaimBMHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReclaimBMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ReclaimBMHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_ReclaimBMHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ReclaimBMHost(ctx, req.(*ReclaimBMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_DeployMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).DeployMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_DeployMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).DeployMachine(ctx, req.(*DeployMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BMProvider_ServiceDesc is the grpc.ServiceDesc for BMProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BMProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.BMProvider",
	HandlerType: (*BMProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMachines",
			Handler:    _BMProvider_ListMachines_Handler,
		},
		{
			MethodName: "GetResourceInfo",
			Handler:    _BMProvider_GetResourceInfo_Handler,
		},
		{
			MethodName: "SetResourcePower",
			Handler:    _BMProvider_SetResourcePower_Handler,
		},
		{
			MethodName: "SetResourceBM2PXEBoot",
			Handler:    _BMProvider_SetResourceBM2PXEBoot_Handler,
		},
		{
			MethodName: "WhoAmI",
			Handler:    _BMProvider_WhoAmI_Handler,
		},
		{
			MethodName: "ListBootSource",
			Handler:    _BMProvider_ListBootSource_Handler,
		},
		{
			MethodName: "ReclaimBMHost",
			Handler:    _BMProvider_ReclaimBMHost_Handler,
		},
		{
			MethodName: "DeployMachine",
			Handler:    _BMProvider_DeployMachine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	VailbreakProxy_ValidateOpenstackIp_FullMethodName   = "/api.VailbreakProxy/ValidateOpenstackIp"
	VailbreakProxy_RevalidateCredentials_FullMethodName = "/api.VailbreakProxy/RevalidateCredentials"
	VailbreakProxy_InjectEnvVariables_FullMethodName    = "/api.VailbreakProxy/InjectEnvVariables"
)

// VailbreakProxyClient is the client API for VailbreakProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VailbreakProxyClient interface {
	ValidateOpenstackIp(ctx context.Context, in *ValidateOpenstackIpRequest, opts ...grpc.CallOption) (*ValidateOpenstackIpResponse, error)
	RevalidateCredentials(ctx context.Context, in *RevalidateCredentialsRequest, opts ...grpc.CallOption) (*RevalidateCredentialsResponse, error)
	InjectEnvVariables(ctx context.Context, in *InjectEnvVariablesRequest, opts ...grpc.CallOption) (*InjectEnvVariablesResponse, error)
}

type vailbreakProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewVailbreakProxyClient(cc grpc.ClientConnInterface) VailbreakProxyClient {
	return &vailbreakProxyClient{cc}
}

func (c *vailbreakProxyClient) ValidateOpenstackIp(ctx context.Context, in *ValidateOpenstackIpRequest, opts ...grpc.CallOption) (*ValidateOpenstackIpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateOpenstackIpResponse)
	err := c.cc.Invoke(ctx, VailbreakProxy_ValidateOpenstackIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vailbreakProxyClient) RevalidateCredentials(ctx context.Context, in *RevalidateCredentialsRequest, opts ...grpc.CallOption) (*RevalidateCredentialsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RevalidateCredentialsResponse)
	err := c.cc.Invoke(ctx, VailbreakProxy_RevalidateCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vailbreakProxyClient) InjectEnvVariables(ctx context.Context, in *InjectEnvVariablesRequest, opts ...grpc.CallOption) (*InjectEnvVariablesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InjectEnvVariablesResponse)
	err := c.cc.Invoke(ctx, VailbreakProxy_InjectEnvVariables_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VailbreakProxyServer is the server API for VailbreakProxy service.
// All implementations must embed UnimplementedVailbreakProxyServer
// for forward compatibility.
type VailbreakProxyServer interface {
	ValidateOpenstackIp(context.Context, *ValidateOpenstackIpRequest) (*ValidateOpenstackIpResponse, error)
	RevalidateCredentials(context.Context, *RevalidateCredentialsRequest) (*RevalidateCredentialsResponse, error)
	InjectEnvVariables(context.Context, *InjectEnvVariablesRequest) (*InjectEnvVariablesResponse, error)
	mustEmbedUnimplementedVailbreakProxyServer()
}

// UnimplementedVailbreakProxyServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVailbreakProxyServer struct{}

func (UnimplementedVailbreakProxyServer) ValidateOpenstackIp(context.Context, *ValidateOpenstackIpRequest) (*ValidateOpenstackIpResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateOpenstackIp not implemented")
}
func (UnimplementedVailbreakProxyServer) RevalidateCredentials(context.Context, *RevalidateCredentialsRequest) (*RevalidateCredentialsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RevalidateCredentials not implemented")
}
func (UnimplementedVailbreakProxyServer) InjectEnvVariables(context.Context, *InjectEnvVariablesRequest) (*InjectEnvVariablesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InjectEnvVariables not implemented")
}
func (UnimplementedVailbreakProxyServer) mustEmbedUnimplementedVailbreakProxyServer() {}
func (UnimplementedVailbreakProxyServer) testEmbeddedByValue()                        {}

// UnsafeVailbreakProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VailbreakProxyServer will
// result in compilation errors.
type UnsafeVailbreakProxyServer interface {
	mustEmbedUnimplementedVailbreakProxyServer()
}

func RegisterVailbreakProxyServer(s grpc.ServiceRegistrar, srv VailbreakProxyServer) {
	// If the following call panics, it indicates UnimplementedVailbreakProxyServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VailbreakProxy_ServiceDesc, srv)
}

func _VailbreakProxy_ValidateOpenstackIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateOpenstackIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VailbreakProxyServer).ValidateOpenstackIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VailbreakProxy_ValidateOpenstackIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VailbreakProxyServer).ValidateOpenstackIp(ctx, req.(*ValidateOpenstackIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VailbreakProxy_RevalidateCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevalidateCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VailbreakProxyServer).RevalidateCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VailbreakProxy_RevalidateCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VailbreakProxyServer).RevalidateCredentials(ctx, req.(*RevalidateCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VailbreakProxy_InjectEnvVariables_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InjectEnvVariablesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VailbreakProxyServer).InjectEnvVariables(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VailbreakProxy_InjectEnvVariables_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VailbreakProxyServer).InjectEnvVariables(ctx, req.(*InjectEnvVariablesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VailbreakProxy_ServiceDesc is the grpc.ServiceDesc for VailbreakProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VailbreakProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.VailbreakProxy",
	HandlerType: (*VailbreakProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateOpenstackIp",
			Handler:    _VailbreakProxy_ValidateOpenstackIp_Handler,
		},
		{
			MethodName: "RevalidateCredentials",
			Handler:    _VailbreakProxy_RevalidateCredentials_Handler,
		},
		{
			MethodName: "InjectEnvVariables",
			Handler:    _VailbreakProxy_InjectEnvVariables_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	StorageArray_ValidateCredentials_FullMethodName          = "/api.StorageArray/ValidateCredentials"
	StorageArray_CreateOrUpdateInitiatorGroup_FullMethodName = "/api.StorageArray/CreateOrUpdateInitiatorGroup"
	StorageArray_MapVolumeToGroup_FullMethodName             = "/api.StorageArray/MapVolumeToGroup"
	StorageArray_UnmapVolumeFromGroup_FullMethodName         = "/api.StorageArray/UnmapVolumeFromGroup"
	StorageArray_GetMappedGroups_FullMethodName              = "/api.StorageArray/GetMappedGroups"
	StorageArray_ResolveCinderVolume_FullMethodName          = "/api.StorageArray/ResolveCinderVolume"
)

// StorageArrayClient is the client API for StorageArray service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StorageArrayClient interface {
	ValidateCredentials(ctx context.Context, in *ValidateStorageCredsRequest, opts ...grpc.CallOption) (*ValidateStorageCredsResponse, error)
	CreateOrUpdateInitiatorGroup(ctx context.Context, in *CreateInitiatorGroupRequest, opts ...grpc.CallOption) (*CreateInitiatorGroupResponse, error)
	MapVolumeToGroup(ctx context.Context, in *MapVolumeRequest, opts ...grpc.CallOption) (*MapVolumeResponse, error)
	UnmapVolumeFromGroup(ctx context.Context, in *UnmapVolumeRequest, opts ...grpc.CallOption) (*UnmapVolumeResponse, error)
	GetMappedGroups(ctx context.Context, in *GetMappedGroupsRequest, opts ...grpc.CallOption) (*GetMappedGroupsResponse, error)
	ResolveCinderVolume(ctx context.Context, in *ResolveCinderVolumeRequest, opts ...grpc.CallOption) (*ResolveCinderVolumeResponse, error)
}

type storageArrayClient struct {
	cc grpc.ClientConnInterface
}

func NewStorageArrayClient(cc grpc.ClientConnInterface) StorageArrayClient {
	return &storageArrayClient{cc}
}

func (c *storageArrayClient) ValidateCredentials(ctx context.Context, in *ValidateStorageCredsRequest, opts ...grpc.CallOption) (*ValidateStorageCredsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateStorageCredsResponse)
	err := c.cc.Invoke(ctx, StorageArray_ValidateCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageArrayClient) CreateOrUpdateInitiatorGroup(ctx context.Context, in *CreateInitiatorGroupRequest, opts ...grpc.CallOption) (*CreateInitiatorGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateInitiatorGroupResponse)
	err := c.cc.Invoke(ctx, StorageArray_CreateOrUpdateInitiatorGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageArrayClient) MapVolumeToGroup(ctx context.Context, in *MapVolumeRequest, opts ...grpc.CallOption) (*MapVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MapVolumeResponse)
	err := c.cc.Invoke(ctx, StorageArray_MapVolumeToGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageArrayClient) UnmapVolumeFromGroup(ctx context.Context, in *UnmapVolumeRequest, opts ...grpc.CallOption) (*UnmapVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnmapVolumeResponse)
	err := c.cc.Invoke(ctx, StorageArray_UnmapVolumeFromGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageArrayClient) GetMappedGroups(ctx context.Context, in *GetMappedGroupsRequest, opts ...grpc.CallOption) (*GetMappedGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMappedGroupsResponse)
	err := c.cc.Invoke(ctx, StorageArray_GetMappedGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageArrayClient) ResolveCinderVolume(ctx context.Context, in *ResolveCinderVolumeRequest, opts ...grpc.CallOption) (*ResolveCinderVolumeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResolveCinderVolumeResponse)
	err := c.cc.Invoke(ctx, StorageArray_ResolveCinderVolume_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StorageArrayServer is the server API for StorageArray service.
// All implementations must embed UnimplementedStorageArrayServer
// for forward compatibility.
type StorageArrayServer interface {
	ValidateCredentials(context.Context, *ValidateStorageCredsRequest) (*ValidateStorageCredsResponse, error)
	CreateOrUpdateInitiatorGroup(context.Context, *CreateInitiatorGroupRequest) (*CreateInitiatorGroupResponse, error)
	MapVolumeToGroup(context.Context, *MapVolumeRequest) (*MapVolumeResponse, error)
	UnmapVolumeFromGroup(context.Context, *UnmapVolumeRequest) (*UnmapVolumeResponse, error)
	GetMappedGroups(context.Context, *GetMappedGroupsRequest) (*GetMappedGroupsResponse, error)
	ResolveCinderVolume(context.Context, *ResolveCinderVolumeRequest) (*ResolveCinderVolumeResponse, error)
	mustEmbedUnimplementedStorageArrayServer()
}

// UnimplementedStorageArrayServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStorageArrayServer struct{}

func (UnimplementedStorageArrayServer) ValidateCredentials(context.Context, *ValidateStorageCredsRequest) (*ValidateStorageCredsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateCredentials not implemented")
}
func (UnimplementedStorageArrayServer) CreateOrUpdateInitiatorGroup(context.Context, *CreateInitiatorGroupRequest) (*CreateInitiatorGroupResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateOrUpdateInitiatorGroup not implemented")
}
func (UnimplementedStorageArrayServer) MapVolumeToGroup(context.Context, *MapVolumeRequest) (*MapVolumeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method MapVolumeToGroup not implemented")
}
func (UnimplementedStorageArrayServer) UnmapVolumeFromGroup(context.Context, *UnmapVolumeRequest) (*UnmapVolumeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UnmapVolumeFromGroup not implemented")
}
func (UnimplementedStorageArrayServer) GetMappedGroups(context.Context, *GetMappedGroupsRequest) (*GetMappedGroupsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMappedGroups not implemented")
}
func (UnimplementedStorageArrayServer) ResolveCinderVolume(context.Context, *ResolveCinderVolumeRequest) (*ResolveCinderVolumeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ResolveCinderVolume not implemented")
}
func (UnimplementedStorageArrayServer) mustEmbedUnimplementedStorageArrayServer() {}
func (UnimplementedStorageArrayServer) testEmbeddedByValue()                      {}

// UnsafeStorageArrayServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StorageArrayServer will
// result in compilation errors.
type UnsafeStorageArrayServer interface {
	mustEmbedUnimplementedStorageArrayServer()
}

func RegisterStorageArrayServer(s grpc.ServiceRegistrar, srv StorageArrayServer) {
	// If the following call panics, it indicates UnimplementedStorageArrayServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&StorageArray_ServiceDesc, srv)
}

func _StorageArray_ValidateCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateStorageCredsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageArrayServer).ValidateCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageArray_ValidateCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageArrayServer).ValidateCredentials(ctx, req.(*ValidateStorageCredsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageArray_CreateOrUpdateInitiatorGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInitiatorGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageArrayServer).CreateOrUpdateInitiatorGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageArray_CreateOrUpdateInitiatorGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageArrayServer).CreateOrUpdateInitiatorGroup(ctx, req.(*CreateInitiatorGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageArray_MapVolumeToGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MapVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageArrayServer).MapVolumeToGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageArray_MapVolumeToGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageArrayServer).MapVolumeToGroup(ctx, req.(*MapVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageArray_UnmapVolumeFromGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnmapVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageArrayServer).UnmapVolumeFromGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageArray_UnmapVolumeFromGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageArrayServer).UnmapVolumeFromGroup(ctx, req.(*UnmapVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageArray_GetMappedGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMappedGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageArrayServer).GetMappedGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageArray_GetMappedGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageArrayServer).GetMappedGroups(ctx, req.(*GetMappedGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageArray_ResolveCinderVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveCinderVolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageArrayServer).ResolveCinderVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StorageArray_ResolveCinderVolume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageArrayServer).ResolveCinderVolume(ctx, req.(*ResolveCinderVolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StorageArray_ServiceDesc is the grpc.ServiceDesc for StorageArray service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StorageArray_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.StorageArray",
	HandlerType: (*StorageArrayServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateCredentials",
			Handler:    _StorageArray_ValidateCredentials_Handler,
		},
		{
			MethodName: "CreateOrUpdateInitiatorGroup",
			Handler:    _StorageArray_CreateOrUpdateInitiatorGroup_Handler,
		},
		{
			MethodName: "MapVolumeToGroup",
			Handler:    _StorageArray_MapVolumeToGroup_Handler,
		},
		{
			MethodName: "UnmapVolumeFromGroup",
			Handler:    _StorageArray_UnmapVolumeFromGroup_Handler,
		},
		{
			MethodName: "GetMappedGroups",
			Handler:    _StorageArray_GetMappedGroups_Handler,
		},
		{
			MethodName: "ResolveCinderVolume",
			Handler:    _StorageArray_ResolveCinderVolume_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}
