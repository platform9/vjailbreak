// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.29.3
// source: api.proto

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// VersionClient is the client API for Version service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionClient interface {
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
	InitiateUpgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
	GetUpgradeProgress(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*UpgradeProgressResponse, error)
	GetAvailableTags(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*AvailableUpdatesResponse, error)
	ConfirmCleanupAndUpgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error)
	CleanupStep(ctx context.Context, in *CleanupStepRequest, opts ...grpc.CallOption) (*CleanupStepResponse, error)
}

type versionClient struct {
	cc grpc.ClientConnInterface
}

func NewVersionClient(cc grpc.ClientConnInterface) VersionClient {
	return &versionClient{cc}
}

func (c *versionClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, "/api.Version/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) InitiateUpgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, "/api.Version/InitiateUpgrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) GetUpgradeProgress(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*UpgradeProgressResponse, error) {
	out := new(UpgradeProgressResponse)
	err := c.cc.Invoke(ctx, "/api.Version/GetUpgradeProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) GetAvailableTags(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*AvailableUpdatesResponse, error) {
	out := new(AvailableUpdatesResponse)
	err := c.cc.Invoke(ctx, "/api.Version/GetAvailableTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) ConfirmCleanupAndUpgrade(ctx context.Context, in *UpgradeRequest, opts ...grpc.CallOption) (*UpgradeResponse, error) {
	out := new(UpgradeResponse)
	err := c.cc.Invoke(ctx, "/api.Version/ConfirmCleanupAndUpgrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *versionClient) CleanupStep(ctx context.Context, in *CleanupStepRequest, opts ...grpc.CallOption) (*CleanupStepResponse, error) {
	out := new(CleanupStepResponse)
	err := c.cc.Invoke(ctx, "/api.Version/CleanupStep", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VersionServer is the server API for Version service.
// All implementations must embed UnimplementedVersionServer
// for forward compatibility
type VersionServer interface {
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
	InitiateUpgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error)
	GetUpgradeProgress(context.Context, *VersionRequest) (*UpgradeProgressResponse, error)
	GetAvailableTags(context.Context, *VersionRequest) (*AvailableUpdatesResponse, error)
	ConfirmCleanupAndUpgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error)
	CleanupStep(context.Context, *CleanupStepRequest) (*CleanupStepResponse, error)
	mustEmbedUnimplementedVersionServer()
}

// UnimplementedVersionServer must be embedded to have forward compatible implementations.
type UnimplementedVersionServer struct {
}

func (UnimplementedVersionServer) Version(context.Context, *VersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedVersionServer) InitiateUpgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitiateUpgrade not implemented")
}
func (UnimplementedVersionServer) GetUpgradeProgress(context.Context, *VersionRequest) (*UpgradeProgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUpgradeProgress not implemented")
}
func (UnimplementedVersionServer) GetAvailableTags(context.Context, *VersionRequest) (*AvailableUpdatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableTags not implemented")
}
func (UnimplementedVersionServer) ConfirmCleanupAndUpgrade(context.Context, *UpgradeRequest) (*UpgradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmCleanupAndUpgrade not implemented")
}
func (UnimplementedVersionServer) CleanupStep(context.Context, *CleanupStepRequest) (*CleanupStepResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanupStep not implemented")
}
func (UnimplementedVersionServer) mustEmbedUnimplementedVersionServer() {}

// UnsafeVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServer will
// result in compilation errors.
type UnsafeVersionServer interface {
	mustEmbedUnimplementedVersionServer()
}

func RegisterVersionServer(s grpc.ServiceRegistrar, srv VersionServer) {
	s.RegisterService(&Version_ServiceDesc, srv)
}

func _Version_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Version/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_InitiateUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).InitiateUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Version/InitiateUpgrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).InitiateUpgrade(ctx, req.(*UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_GetUpgradeProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).GetUpgradeProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Version/GetUpgradeProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).GetUpgradeProgress(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_GetAvailableTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).GetAvailableTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Version/GetAvailableTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).GetAvailableTags(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_ConfirmCleanupAndUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).ConfirmCleanupAndUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Version/ConfirmCleanupAndUpgrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).ConfirmCleanupAndUpgrade(ctx, req.(*UpgradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Version_CleanupStep_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanupStepRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).CleanupStep(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Version/CleanupStep",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).CleanupStep(ctx, req.(*CleanupStepRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Version_ServiceDesc is the grpc.ServiceDesc for Version service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Version_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Version",
	HandlerType: (*VersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Version_Version_Handler,
		},
		{
			MethodName: "InitiateUpgrade",
			Handler:    _Version_InitiateUpgrade_Handler,
		},
		{
			MethodName: "GetUpgradeProgress",
			Handler:    _Version_GetUpgradeProgress_Handler,
		},
		{
			MethodName: "GetAvailableTags",
			Handler:    _Version_GetAvailableTags_Handler,
		},
		{
			MethodName: "ConfirmCleanupAndUpgrade",
			Handler:    _Version_ConfirmCleanupAndUpgrade_Handler,
		},
		{
			MethodName: "CleanupStep",
			Handler:    _Version_CleanupStep_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// VCenterClient is the client API for VCenter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VCenterClient interface {
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error)
	ReclaimVM(ctx context.Context, in *ReclaimVMRequest, opts ...grpc.CallOption) (*ReclaimVMResponse, error)
	CordonHost(ctx context.Context, in *CordonHostRequest, opts ...grpc.CallOption) (*CordonHostResponse, error)
	UnCordonHost(ctx context.Context, in *UnCordonHostRequest, opts ...grpc.CallOption) (*UnCordonHostResponse, error)
	ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error)
}

type vCenterClient struct {
	cc grpc.ClientConnInterface
}

func NewVCenterClient(cc grpc.ClientConnInterface) VCenterClient {
	return &vCenterClient{cc}
}

func (c *vCenterClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, "/api.VCenter/ListVMs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error) {
	out := new(GetVMResponse)
	err := c.cc.Invoke(ctx, "/api.VCenter/GetVM", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) ReclaimVM(ctx context.Context, in *ReclaimVMRequest, opts ...grpc.CallOption) (*ReclaimVMResponse, error) {
	out := new(ReclaimVMResponse)
	err := c.cc.Invoke(ctx, "/api.VCenter/ReclaimVM", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) CordonHost(ctx context.Context, in *CordonHostRequest, opts ...grpc.CallOption) (*CordonHostResponse, error) {
	out := new(CordonHostResponse)
	err := c.cc.Invoke(ctx, "/api.VCenter/CordonHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) UnCordonHost(ctx context.Context, in *UnCordonHostRequest, opts ...grpc.CallOption) (*UnCordonHostResponse, error) {
	out := new(UnCordonHostResponse)
	err := c.cc.Invoke(ctx, "/api.VCenter/UnCordonHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error) {
	out := new(ListHostsResponse)
	err := c.cc.Invoke(ctx, "/api.VCenter/ListHosts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VCenterServer is the server API for VCenter service.
// All implementations must embed UnimplementedVCenterServer
// for forward compatibility
type VCenterServer interface {
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error)
	ReclaimVM(context.Context, *ReclaimVMRequest) (*ReclaimVMResponse, error)
	CordonHost(context.Context, *CordonHostRequest) (*CordonHostResponse, error)
	UnCordonHost(context.Context, *UnCordonHostRequest) (*UnCordonHostResponse, error)
	ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error)
	mustEmbedUnimplementedVCenterServer()
}

// UnimplementedVCenterServer must be embedded to have forward compatible implementations.
type UnimplementedVCenterServer struct {
}

func (UnimplementedVCenterServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedVCenterServer) GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVM not implemented")
}
func (UnimplementedVCenterServer) ReclaimVM(context.Context, *ReclaimVMRequest) (*ReclaimVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReclaimVM not implemented")
}
func (UnimplementedVCenterServer) CordonHost(context.Context, *CordonHostRequest) (*CordonHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CordonHost not implemented")
}
func (UnimplementedVCenterServer) UnCordonHost(context.Context, *UnCordonHostRequest) (*UnCordonHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnCordonHost not implemented")
}
func (UnimplementedVCenterServer) ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHosts not implemented")
}
func (UnimplementedVCenterServer) mustEmbedUnimplementedVCenterServer() {}

// UnsafeVCenterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VCenterServer will
// result in compilation errors.
type UnsafeVCenterServer interface {
	mustEmbedUnimplementedVCenterServer()
}

func RegisterVCenterServer(s grpc.ServiceRegistrar, srv VCenterServer) {
	s.RegisterService(&VCenter_ServiceDesc, srv)
}

func _VCenter_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCenter/ListVMs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).GetVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCenter/GetVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).GetVM(ctx, req.(*GetVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_ReclaimVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReclaimVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ReclaimVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCenter/ReclaimVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ReclaimVM(ctx, req.(*ReclaimVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_CordonHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CordonHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).CordonHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCenter/CordonHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).CordonHost(ctx, req.(*CordonHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_UnCordonHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnCordonHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).UnCordonHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCenter/UnCordonHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).UnCordonHost(ctx, req.(*UnCordonHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_ListHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ListHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VCenter/ListHosts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ListHosts(ctx, req.(*ListHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VCenter_ServiceDesc is the grpc.ServiceDesc for VCenter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VCenter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.VCenter",
	HandlerType: (*VCenterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListVMs",
			Handler:    _VCenter_ListVMs_Handler,
		},
		{
			MethodName: "GetVM",
			Handler:    _VCenter_GetVM_Handler,
		},
		{
			MethodName: "ReclaimVM",
			Handler:    _VCenter_ReclaimVM_Handler,
		},
		{
			MethodName: "CordonHost",
			Handler:    _VCenter_CordonHost_Handler,
		},
		{
			MethodName: "UnCordonHost",
			Handler:    _VCenter_UnCordonHost_Handler,
		},
		{
			MethodName: "ListHosts",
			Handler:    _VCenter_ListHosts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// BMProviderClient is the client API for BMProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BMProviderClient interface {
	ListMachines(ctx context.Context, in *BMListMachinesRequest, opts ...grpc.CallOption) (*BMListMachinesResponse, error)
	GetResourceInfo(ctx context.Context, in *GetResourceInfoRequest, opts ...grpc.CallOption) (*GetResourceInfoResponse, error)
	SetResourcePower(ctx context.Context, in *SetResourcePowerRequest, opts ...grpc.CallOption) (*SetResourcePowerResponse, error)
	SetResourceBM2PXEBoot(ctx context.Context, in *SetResourceBM2PXEBootRequest, opts ...grpc.CallOption) (*SetResourceBM2PXEBootResponse, error)
	WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error)
	ListBootSource(ctx context.Context, in *ListBootSourceRequest, opts ...grpc.CallOption) (*ListBootSourceResponse, error)
	ReclaimBMHost(ctx context.Context, in *ReclaimBMRequest, opts ...grpc.CallOption) (*ReclaimBMResponse, error)
	DeployMachine(ctx context.Context, in *DeployMachineRequest, opts ...grpc.CallOption) (*DeployMachineResponse, error)
}

type bMProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewBMProviderClient(cc grpc.ClientConnInterface) BMProviderClient {
	return &bMProviderClient{cc}
}

func (c *bMProviderClient) ListMachines(ctx context.Context, in *BMListMachinesRequest, opts ...grpc.CallOption) (*BMListMachinesResponse, error) {
	out := new(BMListMachinesResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/ListMachines", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) GetResourceInfo(ctx context.Context, in *GetResourceInfoRequest, opts ...grpc.CallOption) (*GetResourceInfoResponse, error) {
	out := new(GetResourceInfoResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/GetResourceInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) SetResourcePower(ctx context.Context, in *SetResourcePowerRequest, opts ...grpc.CallOption) (*SetResourcePowerResponse, error) {
	out := new(SetResourcePowerResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/SetResourcePower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) SetResourceBM2PXEBoot(ctx context.Context, in *SetResourceBM2PXEBootRequest, opts ...grpc.CallOption) (*SetResourceBM2PXEBootResponse, error) {
	out := new(SetResourceBM2PXEBootResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/SetResourceBM2PXEBoot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error) {
	out := new(WhoAmIResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/WhoAmI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) ListBootSource(ctx context.Context, in *ListBootSourceRequest, opts ...grpc.CallOption) (*ListBootSourceResponse, error) {
	out := new(ListBootSourceResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/ListBootSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) ReclaimBMHost(ctx context.Context, in *ReclaimBMRequest, opts ...grpc.CallOption) (*ReclaimBMResponse, error) {
	out := new(ReclaimBMResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/ReclaimBMHost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) DeployMachine(ctx context.Context, in *DeployMachineRequest, opts ...grpc.CallOption) (*DeployMachineResponse, error) {
	out := new(DeployMachineResponse)
	err := c.cc.Invoke(ctx, "/api.BMProvider/DeployMachine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BMProviderServer is the server API for BMProvider service.
// All implementations must embed UnimplementedBMProviderServer
// for forward compatibility
type BMProviderServer interface {
	ListMachines(context.Context, *BMListMachinesRequest) (*BMListMachinesResponse, error)
	GetResourceInfo(context.Context, *GetResourceInfoRequest) (*GetResourceInfoResponse, error)
	SetResourcePower(context.Context, *SetResourcePowerRequest) (*SetResourcePowerResponse, error)
	SetResourceBM2PXEBoot(context.Context, *SetResourceBM2PXEBootRequest) (*SetResourceBM2PXEBootResponse, error)
	WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error)
	ListBootSource(context.Context, *ListBootSourceRequest) (*ListBootSourceResponse, error)
	ReclaimBMHost(context.Context, *ReclaimBMRequest) (*ReclaimBMResponse, error)
	DeployMachine(context.Context, *DeployMachineRequest) (*DeployMachineResponse, error)
	mustEmbedUnimplementedBMProviderServer()
}

// UnimplementedBMProviderServer must be embedded to have forward compatible implementations.
type UnimplementedBMProviderServer struct {
}

func (UnimplementedBMProviderServer) ListMachines(context.Context, *BMListMachinesRequest) (*BMListMachinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMachines not implemented")
}
func (UnimplementedBMProviderServer) GetResourceInfo(context.Context, *GetResourceInfoRequest) (*GetResourceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResourceInfo not implemented")
}
func (UnimplementedBMProviderServer) SetResourcePower(context.Context, *SetResourcePowerRequest) (*SetResourcePowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetResourcePower not implemented")
}
func (UnimplementedBMProviderServer) SetResourceBM2PXEBoot(context.Context, *SetResourceBM2PXEBootRequest) (*SetResourceBM2PXEBootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetResourceBM2PXEBoot not implemented")
}
func (UnimplementedBMProviderServer) WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WhoAmI not implemented")
}
func (UnimplementedBMProviderServer) ListBootSource(context.Context, *ListBootSourceRequest) (*ListBootSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBootSource not implemented")
}
func (UnimplementedBMProviderServer) ReclaimBMHost(context.Context, *ReclaimBMRequest) (*ReclaimBMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReclaimBMHost not implemented")
}
func (UnimplementedBMProviderServer) DeployMachine(context.Context, *DeployMachineRequest) (*DeployMachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployMachine not implemented")
}
func (UnimplementedBMProviderServer) mustEmbedUnimplementedBMProviderServer() {}

// UnsafeBMProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BMProviderServer will
// result in compilation errors.
type UnsafeBMProviderServer interface {
	mustEmbedUnimplementedBMProviderServer()
}

func RegisterBMProviderServer(s grpc.ServiceRegistrar, srv BMProviderServer) {
	s.RegisterService(&BMProvider_ServiceDesc, srv)
}

func _BMProvider_ListMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BMListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ListMachines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/ListMachines",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ListMachines(ctx, req.(*BMListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_GetResourceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).GetResourceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/GetResourceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).GetResourceInfo(ctx, req.(*GetResourceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_SetResourcePower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourcePowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).SetResourcePower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/SetResourcePower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).SetResourcePower(ctx, req.(*SetResourcePowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_SetResourceBM2PXEBoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourceBM2PXEBootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).SetResourceBM2PXEBoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/SetResourceBM2PXEBoot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).SetResourceBM2PXEBoot(ctx, req.(*SetResourceBM2PXEBootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_WhoAmI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhoAmIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).WhoAmI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/WhoAmI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).WhoAmI(ctx, req.(*WhoAmIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_ListBootSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBootSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ListBootSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/ListBootSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ListBootSource(ctx, req.(*ListBootSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_ReclaimBMHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReclaimBMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ReclaimBMHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/ReclaimBMHost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ReclaimBMHost(ctx, req.(*ReclaimBMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_DeployMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).DeployMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.BMProvider/DeployMachine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).DeployMachine(ctx, req.(*DeployMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BMProvider_ServiceDesc is the grpc.ServiceDesc for BMProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BMProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.BMProvider",
	HandlerType: (*BMProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMachines",
			Handler:    _BMProvider_ListMachines_Handler,
		},
		{
			MethodName: "GetResourceInfo",
			Handler:    _BMProvider_GetResourceInfo_Handler,
		},
		{
			MethodName: "SetResourcePower",
			Handler:    _BMProvider_SetResourcePower_Handler,
		},
		{
			MethodName: "SetResourceBM2PXEBoot",
			Handler:    _BMProvider_SetResourceBM2PXEBoot_Handler,
		},
		{
			MethodName: "WhoAmI",
			Handler:    _BMProvider_WhoAmI_Handler,
		},
		{
			MethodName: "ListBootSource",
			Handler:    _BMProvider_ListBootSource_Handler,
		},
		{
			MethodName: "ReclaimBMHost",
			Handler:    _BMProvider_ReclaimBMHost_Handler,
		},
		{
			MethodName: "DeployMachine",
			Handler:    _BMProvider_DeployMachine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// VailbreakProxyClient is the client API for VailbreakProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VailbreakProxyClient interface {
	ValidateOpenstackIp(ctx context.Context, in *ValidateOpenstackIpRequest, opts ...grpc.CallOption) (*ValidateOpenstackIpResponse, error)
}

type vailbreakProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewVailbreakProxyClient(cc grpc.ClientConnInterface) VailbreakProxyClient {
	return &vailbreakProxyClient{cc}
}

func (c *vailbreakProxyClient) ValidateOpenstackIp(ctx context.Context, in *ValidateOpenstackIpRequest, opts ...grpc.CallOption) (*ValidateOpenstackIpResponse, error) {
	out := new(ValidateOpenstackIpResponse)
	err := c.cc.Invoke(ctx, "/api.VailbreakProxy/ValidateOpenstackIp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VailbreakProxyServer is the server API for VailbreakProxy service.
// All implementations must embed UnimplementedVailbreakProxyServer
// for forward compatibility
type VailbreakProxyServer interface {
	ValidateOpenstackIp(context.Context, *ValidateOpenstackIpRequest) (*ValidateOpenstackIpResponse, error)
	mustEmbedUnimplementedVailbreakProxyServer()
}

// UnimplementedVailbreakProxyServer must be embedded to have forward compatible implementations.
type UnimplementedVailbreakProxyServer struct {
}

func (UnimplementedVailbreakProxyServer) ValidateOpenstackIp(context.Context, *ValidateOpenstackIpRequest) (*ValidateOpenstackIpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateOpenstackIp not implemented")
}
func (UnimplementedVailbreakProxyServer) mustEmbedUnimplementedVailbreakProxyServer() {}

// UnsafeVailbreakProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VailbreakProxyServer will
// result in compilation errors.
type UnsafeVailbreakProxyServer interface {
	mustEmbedUnimplementedVailbreakProxyServer()
}

func RegisterVailbreakProxyServer(s grpc.ServiceRegistrar, srv VailbreakProxyServer) {
	s.RegisterService(&VailbreakProxy_ServiceDesc, srv)
}

func _VailbreakProxy_ValidateOpenstackIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateOpenstackIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VailbreakProxyServer).ValidateOpenstackIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.VailbreakProxy/ValidateOpenstackIp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VailbreakProxyServer).ValidateOpenstackIp(ctx, req.(*ValidateOpenstackIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VailbreakProxy_ServiceDesc is the grpc.ServiceDesc for VailbreakProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VailbreakProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.VailbreakProxy",
	HandlerType: (*VailbreakProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateOpenstackIp",
			Handler:    _VailbreakProxy_ValidateOpenstackIp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}
