// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: sdk/proto/v1/api.proto

// editor setting.
// Tab size=4; Tabs as spaces; Clean up trailing whitespaces.

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Version_Version_FullMethodName = "/api.Version/Version"
)

// VersionClient is the client API for Version service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VersionClient interface {
	Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error)
}

type versionClient struct {
	cc grpc.ClientConnInterface
}

func NewVersionClient(cc grpc.ClientConnInterface) VersionClient {
	return &versionClient{cc}
}

func (c *versionClient) Version(ctx context.Context, in *VersionRequest, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, Version_Version_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VersionServer is the server API for Version service.
// All implementations must embed UnimplementedVersionServer
// for forward compatibility.
type VersionServer interface {
	Version(context.Context, *VersionRequest) (*VersionResponse, error)
	mustEmbedUnimplementedVersionServer()
}

// UnimplementedVersionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVersionServer struct{}

func (UnimplementedVersionServer) Version(context.Context, *VersionRequest) (*VersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedVersionServer) mustEmbedUnimplementedVersionServer() {}
func (UnimplementedVersionServer) testEmbeddedByValue()                 {}

// UnsafeVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VersionServer will
// result in compilation errors.
type UnsafeVersionServer interface {
	mustEmbedUnimplementedVersionServer()
}

func RegisterVersionServer(s grpc.ServiceRegistrar, srv VersionServer) {
	// If the following call pancis, it indicates UnimplementedVersionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Version_ServiceDesc, srv)
}

func _Version_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VersionServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Version_Version_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VersionServer).Version(ctx, req.(*VersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Version_ServiceDesc is the grpc.ServiceDesc for Version service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Version_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.Version",
	HandlerType: (*VersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Version",
			Handler:    _Version_Version_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	VCenter_ListVMs_FullMethodName      = "/api.VCenter/ListVMs"
	VCenter_GetVM_FullMethodName        = "/api.VCenter/GetVM"
	VCenter_ReclaimVM_FullMethodName    = "/api.VCenter/ReclaimVM"
	VCenter_CordonHost_FullMethodName   = "/api.VCenter/CordonHost"
	VCenter_UnCordonHost_FullMethodName = "/api.VCenter/UnCordonHost"
	VCenter_ListHosts_FullMethodName    = "/api.VCenter/ListHosts"
)

// VCenterClient is the client API for VCenter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VCenterClient interface {
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error)
	ReclaimVM(ctx context.Context, in *ReclaimVMRequest, opts ...grpc.CallOption) (*ReclaimVMResponse, error)
	CordonHost(ctx context.Context, in *CordonHostRequest, opts ...grpc.CallOption) (*CordonHostResponse, error)
	UnCordonHost(ctx context.Context, in *UnCordonHostRequest, opts ...grpc.CallOption) (*UnCordonHostResponse, error)
	ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error)
}

type vCenterClient struct {
	cc grpc.ClientConnInterface
}

func NewVCenterClient(cc grpc.ClientConnInterface) VCenterClient {
	return &vCenterClient{cc}
}

func (c *vCenterClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, VCenter_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) GetVM(ctx context.Context, in *GetVMRequest, opts ...grpc.CallOption) (*GetVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVMResponse)
	err := c.cc.Invoke(ctx, VCenter_GetVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) ReclaimVM(ctx context.Context, in *ReclaimVMRequest, opts ...grpc.CallOption) (*ReclaimVMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReclaimVMResponse)
	err := c.cc.Invoke(ctx, VCenter_ReclaimVM_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) CordonHost(ctx context.Context, in *CordonHostRequest, opts ...grpc.CallOption) (*CordonHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CordonHostResponse)
	err := c.cc.Invoke(ctx, VCenter_CordonHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) UnCordonHost(ctx context.Context, in *UnCordonHostRequest, opts ...grpc.CallOption) (*UnCordonHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnCordonHostResponse)
	err := c.cc.Invoke(ctx, VCenter_UnCordonHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vCenterClient) ListHosts(ctx context.Context, in *ListHostsRequest, opts ...grpc.CallOption) (*ListHostsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListHostsResponse)
	err := c.cc.Invoke(ctx, VCenter_ListHosts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VCenterServer is the server API for VCenter service.
// All implementations must embed UnimplementedVCenterServer
// for forward compatibility.
type VCenterServer interface {
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error)
	ReclaimVM(context.Context, *ReclaimVMRequest) (*ReclaimVMResponse, error)
	CordonHost(context.Context, *CordonHostRequest) (*CordonHostResponse, error)
	UnCordonHost(context.Context, *UnCordonHostRequest) (*UnCordonHostResponse, error)
	ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error)
	mustEmbedUnimplementedVCenterServer()
}

// UnimplementedVCenterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVCenterServer struct{}

func (UnimplementedVCenterServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedVCenterServer) GetVM(context.Context, *GetVMRequest) (*GetVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVM not implemented")
}
func (UnimplementedVCenterServer) ReclaimVM(context.Context, *ReclaimVMRequest) (*ReclaimVMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReclaimVM not implemented")
}
func (UnimplementedVCenterServer) CordonHost(context.Context, *CordonHostRequest) (*CordonHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CordonHost not implemented")
}
func (UnimplementedVCenterServer) UnCordonHost(context.Context, *UnCordonHostRequest) (*UnCordonHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnCordonHost not implemented")
}
func (UnimplementedVCenterServer) ListHosts(context.Context, *ListHostsRequest) (*ListHostsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListHosts not implemented")
}
func (UnimplementedVCenterServer) mustEmbedUnimplementedVCenterServer() {}
func (UnimplementedVCenterServer) testEmbeddedByValue()                 {}

// UnsafeVCenterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VCenterServer will
// result in compilation errors.
type UnsafeVCenterServer interface {
	mustEmbedUnimplementedVCenterServer()
}

func RegisterVCenterServer(s grpc.ServiceRegistrar, srv VCenterServer) {
	// If the following call pancis, it indicates UnimplementedVCenterServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VCenter_ServiceDesc, srv)
}

func _VCenter_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_GetVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).GetVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_GetVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).GetVM(ctx, req.(*GetVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_ReclaimVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReclaimVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ReclaimVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_ReclaimVM_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ReclaimVM(ctx, req.(*ReclaimVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_CordonHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CordonHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).CordonHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_CordonHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).CordonHost(ctx, req.(*CordonHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_UnCordonHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnCordonHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).UnCordonHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_UnCordonHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).UnCordonHost(ctx, req.(*UnCordonHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VCenter_ListHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHostsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VCenterServer).ListHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VCenter_ListHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VCenterServer).ListHosts(ctx, req.(*ListHostsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VCenter_ServiceDesc is the grpc.ServiceDesc for VCenter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VCenter_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.VCenter",
	HandlerType: (*VCenterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListVMs",
			Handler:    _VCenter_ListVMs_Handler,
		},
		{
			MethodName: "GetVM",
			Handler:    _VCenter_GetVM_Handler,
		},
		{
			MethodName: "ReclaimVM",
			Handler:    _VCenter_ReclaimVM_Handler,
		},
		{
			MethodName: "CordonHost",
			Handler:    _VCenter_CordonHost_Handler,
		},
		{
			MethodName: "UnCordonHost",
			Handler:    _VCenter_UnCordonHost_Handler,
		},
		{
			MethodName: "ListHosts",
			Handler:    _VCenter_ListHosts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	BMProvider_ListMachines_FullMethodName          = "/api.BMProvider/ListMachines"
	BMProvider_GetResourceInfo_FullMethodName       = "/api.BMProvider/GetResourceInfo"
	BMProvider_SetResourcePower_FullMethodName      = "/api.BMProvider/SetResourcePower"
	BMProvider_SetResourceBM2PXEBoot_FullMethodName = "/api.BMProvider/SetResourceBM2PXEBoot"
	BMProvider_WhoAmI_FullMethodName                = "/api.BMProvider/WhoAmI"
	BMProvider_ListBootSource_FullMethodName        = "/api.BMProvider/ListBootSource"
	BMProvider_ReclaimBMHost_FullMethodName         = "/api.BMProvider/ReclaimBMHost"
	BMProvider_DeployMachine_FullMethodName         = "/api.BMProvider/DeployMachine"
)

// BMProviderClient is the client API for BMProvider service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BMProviderClient interface {
	ListMachines(ctx context.Context, in *BMListMachinesRequest, opts ...grpc.CallOption) (*BMListMachinesResponse, error)
	GetResourceInfo(ctx context.Context, in *GetResourceInfoRequest, opts ...grpc.CallOption) (*GetResourceInfoResponse, error)
	SetResourcePower(ctx context.Context, in *SetResourcePowerRequest, opts ...grpc.CallOption) (*SetResourcePowerResponse, error)
	SetResourceBM2PXEBoot(ctx context.Context, in *SetResourceBM2PXEBootRequest, opts ...grpc.CallOption) (*SetResourceBM2PXEBootResponse, error)
	WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error)
	ListBootSource(ctx context.Context, in *ListBootSourceRequest, opts ...grpc.CallOption) (*ListBootSourceResponse, error)
	ReclaimBMHost(ctx context.Context, in *ReclaimBMRequest, opts ...grpc.CallOption) (*ReclaimBMResponse, error)
	DeployMachine(ctx context.Context, in *DeployMachineRequest, opts ...grpc.CallOption) (*DeployMachineResponse, error)
}

type bMProviderClient struct {
	cc grpc.ClientConnInterface
}

func NewBMProviderClient(cc grpc.ClientConnInterface) BMProviderClient {
	return &bMProviderClient{cc}
}

func (c *bMProviderClient) ListMachines(ctx context.Context, in *BMListMachinesRequest, opts ...grpc.CallOption) (*BMListMachinesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BMListMachinesResponse)
	err := c.cc.Invoke(ctx, BMProvider_ListMachines_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) GetResourceInfo(ctx context.Context, in *GetResourceInfoRequest, opts ...grpc.CallOption) (*GetResourceInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResourceInfoResponse)
	err := c.cc.Invoke(ctx, BMProvider_GetResourceInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) SetResourcePower(ctx context.Context, in *SetResourcePowerRequest, opts ...grpc.CallOption) (*SetResourcePowerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResourcePowerResponse)
	err := c.cc.Invoke(ctx, BMProvider_SetResourcePower_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) SetResourceBM2PXEBoot(ctx context.Context, in *SetResourceBM2PXEBootRequest, opts ...grpc.CallOption) (*SetResourceBM2PXEBootResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResourceBM2PXEBootResponse)
	err := c.cc.Invoke(ctx, BMProvider_SetResourceBM2PXEBoot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) WhoAmI(ctx context.Context, in *WhoAmIRequest, opts ...grpc.CallOption) (*WhoAmIResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WhoAmIResponse)
	err := c.cc.Invoke(ctx, BMProvider_WhoAmI_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) ListBootSource(ctx context.Context, in *ListBootSourceRequest, opts ...grpc.CallOption) (*ListBootSourceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBootSourceResponse)
	err := c.cc.Invoke(ctx, BMProvider_ListBootSource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) ReclaimBMHost(ctx context.Context, in *ReclaimBMRequest, opts ...grpc.CallOption) (*ReclaimBMResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReclaimBMResponse)
	err := c.cc.Invoke(ctx, BMProvider_ReclaimBMHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bMProviderClient) DeployMachine(ctx context.Context, in *DeployMachineRequest, opts ...grpc.CallOption) (*DeployMachineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeployMachineResponse)
	err := c.cc.Invoke(ctx, BMProvider_DeployMachine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BMProviderServer is the server API for BMProvider service.
// All implementations must embed UnimplementedBMProviderServer
// for forward compatibility.
type BMProviderServer interface {
	ListMachines(context.Context, *BMListMachinesRequest) (*BMListMachinesResponse, error)
	GetResourceInfo(context.Context, *GetResourceInfoRequest) (*GetResourceInfoResponse, error)
	SetResourcePower(context.Context, *SetResourcePowerRequest) (*SetResourcePowerResponse, error)
	SetResourceBM2PXEBoot(context.Context, *SetResourceBM2PXEBootRequest) (*SetResourceBM2PXEBootResponse, error)
	WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error)
	ListBootSource(context.Context, *ListBootSourceRequest) (*ListBootSourceResponse, error)
	ReclaimBMHost(context.Context, *ReclaimBMRequest) (*ReclaimBMResponse, error)
	DeployMachine(context.Context, *DeployMachineRequest) (*DeployMachineResponse, error)
	mustEmbedUnimplementedBMProviderServer()
}

// UnimplementedBMProviderServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBMProviderServer struct{}

func (UnimplementedBMProviderServer) ListMachines(context.Context, *BMListMachinesRequest) (*BMListMachinesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMachines not implemented")
}
func (UnimplementedBMProviderServer) GetResourceInfo(context.Context, *GetResourceInfoRequest) (*GetResourceInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResourceInfo not implemented")
}
func (UnimplementedBMProviderServer) SetResourcePower(context.Context, *SetResourcePowerRequest) (*SetResourcePowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetResourcePower not implemented")
}
func (UnimplementedBMProviderServer) SetResourceBM2PXEBoot(context.Context, *SetResourceBM2PXEBootRequest) (*SetResourceBM2PXEBootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetResourceBM2PXEBoot not implemented")
}
func (UnimplementedBMProviderServer) WhoAmI(context.Context, *WhoAmIRequest) (*WhoAmIResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WhoAmI not implemented")
}
func (UnimplementedBMProviderServer) ListBootSource(context.Context, *ListBootSourceRequest) (*ListBootSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBootSource not implemented")
}
func (UnimplementedBMProviderServer) ReclaimBMHost(context.Context, *ReclaimBMRequest) (*ReclaimBMResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReclaimBMHost not implemented")
}
func (UnimplementedBMProviderServer) DeployMachine(context.Context, *DeployMachineRequest) (*DeployMachineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployMachine not implemented")
}
func (UnimplementedBMProviderServer) mustEmbedUnimplementedBMProviderServer() {}
func (UnimplementedBMProviderServer) testEmbeddedByValue()                    {}

// UnsafeBMProviderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BMProviderServer will
// result in compilation errors.
type UnsafeBMProviderServer interface {
	mustEmbedUnimplementedBMProviderServer()
}

func RegisterBMProviderServer(s grpc.ServiceRegistrar, srv BMProviderServer) {
	// If the following call pancis, it indicates UnimplementedBMProviderServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BMProvider_ServiceDesc, srv)
}

func _BMProvider_ListMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BMListMachinesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ListMachines(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_ListMachines_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ListMachines(ctx, req.(*BMListMachinesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_GetResourceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).GetResourceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_GetResourceInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).GetResourceInfo(ctx, req.(*GetResourceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_SetResourcePower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourcePowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).SetResourcePower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_SetResourcePower_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).SetResourcePower(ctx, req.(*SetResourcePowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_SetResourceBM2PXEBoot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetResourceBM2PXEBootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).SetResourceBM2PXEBoot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_SetResourceBM2PXEBoot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).SetResourceBM2PXEBoot(ctx, req.(*SetResourceBM2PXEBootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_WhoAmI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WhoAmIRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).WhoAmI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_WhoAmI_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).WhoAmI(ctx, req.(*WhoAmIRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_ListBootSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBootSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ListBootSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_ListBootSource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ListBootSource(ctx, req.(*ListBootSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_ReclaimBMHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReclaimBMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).ReclaimBMHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_ReclaimBMHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).ReclaimBMHost(ctx, req.(*ReclaimBMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BMProvider_DeployMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployMachineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BMProviderServer).DeployMachine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BMProvider_DeployMachine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BMProviderServer).DeployMachine(ctx, req.(*DeployMachineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BMProvider_ServiceDesc is the grpc.ServiceDesc for BMProvider service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BMProvider_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.BMProvider",
	HandlerType: (*BMProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListMachines",
			Handler:    _BMProvider_ListMachines_Handler,
		},
		{
			MethodName: "GetResourceInfo",
			Handler:    _BMProvider_GetResourceInfo_Handler,
		},
		{
			MethodName: "SetResourcePower",
			Handler:    _BMProvider_SetResourcePower_Handler,
		},
		{
			MethodName: "SetResourceBM2PXEBoot",
			Handler:    _BMProvider_SetResourceBM2PXEBoot_Handler,
		},
		{
			MethodName: "WhoAmI",
			Handler:    _BMProvider_WhoAmI_Handler,
		},
		{
			MethodName: "ListBootSource",
			Handler:    _BMProvider_ListBootSource_Handler,
		},
		{
			MethodName: "ReclaimBMHost",
			Handler:    _BMProvider_ReclaimBMHost_Handler,
		},
		{
			MethodName: "DeployMachine",
			Handler:    _BMProvider_DeployMachine_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}

const (
	VailbreakProxy_ValidateOpenstackIp_FullMethodName = "/api.VailbreakProxy/ValidateOpenstackIp"
)

// VailbreakProxyClient is the client API for VailbreakProxy service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VailbreakProxyClient interface {
	ValidateOpenstackIp(ctx context.Context, in *ValidateOpenstackIpRequest, opts ...grpc.CallOption) (*ValidateOpenstackIpResponse, error)
}

type vailbreakProxyClient struct {
	cc grpc.ClientConnInterface
}

func NewVailbreakProxyClient(cc grpc.ClientConnInterface) VailbreakProxyClient {
	return &vailbreakProxyClient{cc}
}

func (c *vailbreakProxyClient) ValidateOpenstackIp(ctx context.Context, in *ValidateOpenstackIpRequest, opts ...grpc.CallOption) (*ValidateOpenstackIpResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateOpenstackIpResponse)
	err := c.cc.Invoke(ctx, VailbreakProxy_ValidateOpenstackIp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VailbreakProxyServer is the server API for VailbreakProxy service.
// All implementations must embed UnimplementedVailbreakProxyServer
// for forward compatibility.
type VailbreakProxyServer interface {
	ValidateOpenstackIp(context.Context, *ValidateOpenstackIpRequest) (*ValidateOpenstackIpResponse, error)
	mustEmbedUnimplementedVailbreakProxyServer()
}

// UnimplementedVailbreakProxyServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVailbreakProxyServer struct{}

func (UnimplementedVailbreakProxyServer) ValidateOpenstackIp(context.Context, *ValidateOpenstackIpRequest) (*ValidateOpenstackIpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateOpenstackIp not implemented")
}
func (UnimplementedVailbreakProxyServer) mustEmbedUnimplementedVailbreakProxyServer() {}
func (UnimplementedVailbreakProxyServer) testEmbeddedByValue()                        {}

// UnsafeVailbreakProxyServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VailbreakProxyServer will
// result in compilation errors.
type UnsafeVailbreakProxyServer interface {
	mustEmbedUnimplementedVailbreakProxyServer()
}

func RegisterVailbreakProxyServer(s grpc.ServiceRegistrar, srv VailbreakProxyServer) {
	// If the following call pancis, it indicates UnimplementedVailbreakProxyServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VailbreakProxy_ServiceDesc, srv)
}

func _VailbreakProxy_ValidateOpenstackIp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateOpenstackIpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VailbreakProxyServer).ValidateOpenstackIp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VailbreakProxy_ValidateOpenstackIp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VailbreakProxyServer).ValidateOpenstackIp(ctx, req.(*ValidateOpenstackIpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VailbreakProxy_ServiceDesc is the grpc.ServiceDesc for VailbreakProxy service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VailbreakProxy_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.VailbreakProxy",
	HandlerType: (*VailbreakProxyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ValidateOpenstackIp",
			Handler:    _VailbreakProxy_ValidateOpenstackIp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sdk/proto/v1/api.proto",
}
