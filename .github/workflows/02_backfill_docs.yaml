name: Manual Docs Backfill

env:
  QCOW2_IMG: ${{ vars.REGISTRY }}/${{ vars.REPO }}/vjailbreak

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Single release tag to process'
        required: false
      process_all_recent:
        description: 'Process all missing releases'
        required: true
        default: true
        type: boolean

jobs:
  backfill-release-notes:
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout gh-pages Branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Install GitHub CLI and jq
        run: sudo apt-get update && sudo apt-get install -y gh jq skopeo

      - name: Process and Generate Release Notes
        id: process_releases
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # This function processes a single release tag
          process_release() {
            local RELEASE_TAG=$1
            if [ -f "docs/src/content/docs/release_docs/$RELEASE_TAG.md" ]; then
              echo "Documentation for $RELEASE_TAG already exists, skipping."
              return 0
            fi

            local QCOW_IMAGE_URI="docker://${{ env.QCOW2_IMG }}:${RELEASE_TAG}"
            echo "--> Checking for image: $QCOW_IMAGE_URI"
            if ! skopeo inspect "$QCOW_IMAGE_URI" &>/dev/null; then
              echo "::warning::Image not found for tag $RELEASE_TAG. Skipping doc generation for this release."
              return 0
            fi
            echo "--> Image found. Proceeding with doc generation."

            echo ">>> Processing release: $RELEASE_TAG"
            RELEASE_NOTES=$(gh release view "$RELEASE_TAG" --json body --template '{{.body}}' || echo "")
            if [ -z "$RELEASE_NOTES" ]; then
              echo "No release notes found for $RELEASE_TAG, skipping."; return 0
            fi

            local ALL_TAGS_SORTED=$(git tag --sort=version:refname)
            local LAST_TAG=$(echo "$ALL_TAGS_SORTED" | grep -B 1 -x "$RELEASE_TAG" | head -n 1)

            if [[ -n "$LAST_TAG" && "$LAST_TAG" != "$RELEASE_TAG" ]]; then
              echo "Found previous version: $LAST_TAG. Updating docs..."
              sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/content/docs/introduction/getting_started.mdx
              sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/components/githubRelease.astro
              sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/content/docs/index.mdx
            fi

            local FILE_NAME="docs/src/content/docs/release_docs/$RELEASE_TAG.md"
            mkdir -p "$(dirname "$FILE_NAME")"
            { echo "---"; echo "title:  $RELEASE_TAG"; echo "description: Release Notes for $RELEASE_TAG"; echo "---"; echo ""; echo "$RELEASE_NOTES"; } > "$FILE_NAME"
            echo "Created documentation file: $FILE_NAME"
            PROCESSED_LIST_TEMP+="$RELEASE_TAG "
          }
          export -f process_release
          PROCESSED_LIST_TEMP=""

          if [[ -n "${{ github.event.inputs.release_tag }}" ]]; then
            echo "Processing single specified release..."
            process_release "${{ github.event.inputs.release_tag }}"
          elif [[ "${{ github.event.inputs.process_all_recent }}" == "true" ]]; then
            echo "Processing all recent missing releases..."
            ALL_RELEASES=$(gh release list --limit 100 --json tagName --jq '.[].tagName' | sort -V)
            for TAG in $ALL_RELEASES; do process_release "$TAG"; done
          fi
          
          echo "PROCESSED_RELEASES=${PROCESSED_LIST_TEMP}" >> $GITHUB_OUTPUT

      - name: Archive and Delete Old Release Notes
        if: steps.process_releases.outputs.PROCESSED_RELEASES != ''
        run: |
          echo "Archiving and cleaning old release notes..."
          mapfile -t ALL_VERSIONS < <(find docs/src/content/docs/release_docs -name "v*.md" -printf "%f\n" | sed -e 's/^v//' -e 's/\.md$//' | sort -V)
          mapfile -t TOP_5_ARRAY < <(printf '%s\n' "${ALL_VERSIONS[@]}" | tail -n 5)
          if [ ${#TOP_5_ARRAY[@]} -eq 0 ]; then exit 0; fi
          echo "Keeping Top 5 versions:"; printf 'v%s\n' "${TOP_5_ARRAY[@]}"
          for v in "${ALL_VERSIONS[@]}"; do
            IS_IN_TOP_5=false
            for top_v in "${TOP_5_ARRAY[@]}"; do if [[ "$v" == "$top_v" ]]; then IS_IN_TOP_5=true; break; fi; done
            if ! $IS_IN_TOP_5; then
              FILE_TO_PROCESS="docs/src/content/docs/release_docs/v${v}.md"
              if [ -f "$FILE_TO_PROCESS" ]; then
                echo "Archiving and deleting: v${v}.md"
                awk 'BEGIN { in_yaml=0 } /^---$/ { in_yaml = !in_yaml; next } in_yaml { if ($1 == "title:") { sub(/^title:[[:space:]]*v/, "## v"); print; }; next; } { sub(/^##/, "###"); print }' "$FILE_TO_PROCESS" >> docs/src/content/docs/archives/release_notes.md
                rm "$FILE_TO_PROCESS"
              fi
            fi
          done

      - name: Create PR with changes
        if: steps.process_releases.outputs.PROCESSED_RELEASES != ''
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions Bot"
          
          TIMESTAMP=$(date +%s)
          NEW_BRANCH="backfill-docs-$TIMESTAMP"
          RELEASE_TAG="${{ steps.process_releases.outputs.PROCESSED_RELEASES }}"
          
          git checkout -b "$NEW_BRANCH"
          git add docs/
          
          if ! git diff --cached --quiet; then
            git commit -m "docs: Backfill missing release documentation for $RELEASE_TAG"
            git push origin "$NEW_BRANCH"
            
            for i in {1..3}; do
              if gh pr create --base gh-pages --head "$NEW_BRANCH" --title "docs: Backfill release documentation for $RELEASE_TAG" --body "This PR was automatically generated to backfill documentation for one or more releases."; then
                echo "PR created successfully on attempt $i."
                exit 0
              fi

              if [ $i -eq 3 ]; then
                echo "PR creation failed after 3 attempts."
                exit 1
              fi
              
              echo "PR creation failed on attempt $i. Retrying in 15 seconds..."
              sleep 15
            done
          else
            echo "No changes were detected to create a pull request."
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}